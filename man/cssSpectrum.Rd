% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/wrassp_cssSpectrum.R
\name{cssSpectrum}
\alias{cssSpectrum}
\title{Compute the cepstrally smoothed spectrum}
\usage{
cssSpectrum(
  listOfFiles = NULL,
  optLogFilePath = NULL,
  beginTime = 0,
  centerTime = FALSE,
  endTime = 0,
  resolution = 40,
  fftLength = 0,
  windowShift = 5,
  numCeps = 0,
  window = "BLACKMAN",
  toFile = TRUE,
  explicitExt = "cep",
  outputDirectory = NULL,
  assertLossless = NULL,
  logToFile = FALSE,
  keepConverted = FALSE,
  verbose = TRUE
)
}
\arguments{
\item{listOfFiles}{vector of file paths to be processed by function}

\item{beginTime}{the time point (in seconds) of the start of the analysed
interval. A NULL or 0 is interpreted as the start of the signal file.
If a vector of time points is supplied, the length of that vector needs
to correspond with the length of \code{listOfFiles}.}

\item{centerTime}{sets a single-frame analysis time point (in seconds).
Overrides \code{beginTime}, \code{endTime} and \code{windowShift} parameters.}

\item{endTime}{the time point (in seconds) of the end of the analysed
interval. A NULL or 0 is interpreted as the end of the signal file.
If a vector of time points is supplied, the length of that vector needs
to correspond with the length of \code{listOfFiles}.}

\item{resolution}{= \if{html}{\out{<freq>}}: set FFT length to the smallest value which
results in a frequency resolution of \if{html}{\out{<freq>}} Hz or better (default: 40.0)}

\item{fftLength}{= \if{html}{\out{<num>}}: set FFT length to \if{html}{\out{<num>}} points (overrules default
and 'resolution' option)}

\item{windowShift}{the amount of time (in ms) that the analysis window will
be shifted between analysis frames}

\item{numCeps}{= \if{html}{\out{<num>}}: set number of cepstral coefficients used to \if{html}{\out{<num>}}
(default: sampling rate in kHz + 1; minimum: 2)}

\item{window}{= the analysis window function type ("BLACKMAN" by default).
See \link{AsspWindowTypes} for a list of supported window types.}

\item{toFile}{Should the function write the results to a file, with the
(default) file extension (\code{TRUE}) or returned as a list of
\link{AsspDataObj} objects (\code{FALSE})?}

\item{explicitExt}{the file extension will be used when
result files are written (\code{toFile=TRUE}), but the file extension can be
set to something else using this function argument.}

\item{outputDirectory}{directory in which output files are stored. Defaults
to NULL which means that the result file will be stored in the same
directory as the input file.}

\item{assertLossless}{an optional list of file extensions that the user wants to assert
contains losslessly encoded signals data.}

\item{logToFile}{whether to log commands to a separate logfile in the
\code{outputDirectory}. Logging will otherwise be in the function-specific logging
namespace of \link{logger} and will be put wherever this namespace is defined to place its output.
See \link[logger:log_appender]{logger::log_appender} for details.}

\item{verbose}{display verbose information about processing steps taken, as
well as progress bars.}
}
\value{
The number of successfully written files (if \code{toFile=TRUE}), or a vector of \code{AsspDataObj} objects (if \code{toFile=FALSE}).
}
\description{
Short-term spectral analysis of the signals in  \code{listOfFiles}
using the Fast Fourier Transform and cepstral smoothing.
}
\details{
The results will be will be written to an SSFF formated file with the base
name of the input file and extension \emph{.css} in a track \emph{CSS\link{dB}} which contains amplitudes (on a dB scale) of
all frequencies in the computed spectrum.

The function is a re-write of the \link[wrassp:cssSpectrum]{wrassp::cssSpectrum} function, but
with media pre-conversion, better checking of preconditions such as the
input file existance, structured logging, and the use of a more modern
framework for user feedback.

The native file type of this function is "wav" files (in "pcm_s16le"
format), SUNs "au", NIST, or CSL formats (kay or NSP extension). Input
signal conversion, when needed, is done by
\href{https://ffmpeg.org/libavcodec.html}{libavcodec} and the excellent \link[av:encoding]{av::av_audio_convert}
wrapper function
}
\note{
This function takes some time to apply but also result in data in a relatively large matrix.
It is therefore not usually efficient to store intermediate results in a cache.
However, if the number of signals it will be applied to
is \emph{very} large, then caching of results may be warranted.
}
\examples{
# get path to audio file
path2wav <- list.files(system.file("samples","sustained", package = "superassp"), pattern = glob2rx("a1.wav"), full.names = TRUE)

# calculate cepstrally smoothed spectrum
res <- cssSpectrum(path2wav, toFile=FALSE)
resolution <- attr(res,"origFreq") / ncol(res[[1]])

# plot spectral values at midpoint of signal
plot(y=res[["CSS[dB]"]][400,],
    x=seq(1,ncol(res[[1]]),1)* resolution,
    type='l',
    xlab='Frequency (Hz)',
    ylab='Amplitude (dB)')
     
}
\seealso{
\code{\link{dftSpectrum}}, \code{\link{lpsSpectrum}}, \code{\link{cepstrum}};
all derived from libassp's spectrum function.

\link[wrassp:cssSpectrum]{wrassp::cssSpectrum}

\link{AsspWindowTypes}

\link[av:encoding]{av::av_audio_convert}
}
\author{
Raphael Winkelmann

Lasse Bombien

Fredrik NylÃ©n
}
