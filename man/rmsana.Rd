% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/wrassp_rmsana.R
\name{rmsana}
\alias{rmsana}
\title{Short-term Root Mean Square amplitude of signals}
\usage{
rmsana(
  listOfFiles = NULL,
  beginTime = 0,
  centerTime = FALSE,
  endTime = 0,
  windowShift = 5,
  windowSize = 20,
  effectiveLength = TRUE,
  linear = FALSE,
  window = "HAMMING",
  toFile = TRUE,
  explicitExt = "rms",
  outputDirectory = NULL,
  knownLossless = c("wav", "flac", "aiff", "wv", "tta", "caf", "au", "kay", "nist",
    "nsp"),
  logToFile = FALSE,
  convertOverwrites = FALSE,
  keepConverted = FALSE,
  verbose = TRUE
)
}
\arguments{
\item{listOfFiles}{vector of file paths to be processed by function}

\item{beginTime}{the time point (in seconds) of the start of the analysed
interval. A NULL or 0 is interpreted as the start of the signal file.}

\item{centerTime}{sets a single-frame analysis time point (in seconds).
Overrides \code{beginTime}, \code{endTime} and \code{windowShift} parameters.}

\item{endTime}{the time point (in seconds) of the end of the analysed
interval. A NULL or 0 is interpreted as the end of the signal file.}

\item{windowShift}{the amount of time (in ms) that the analysis window will
be shifted between analysis frames}

\item{windowSize}{the analysis window size (in ms); overrides the effect of
the \code{effectiveLength} parameter}

\item{effectiveLength}{make window size effective rather than exact}

\item{linear}{Should linear RMS values be computed? The default (\code{FALSE})
means that the output will be on a logarithmic decibel scale (dB).}

\item{window}{= the analysis window function type ("BLACKMAN" by default).
See \link{AsspWindowTypes} for a list of supported window types.}

\item{toFile}{Should the function write the results to a file, with the
(default) file extension \emph{.acf} (\code{TRUE}) or returned as a list of
\link{AsspDataObj} objects (\code{FALSE})?}

\item{explicitExt}{by default an \emph{.acf} file extension will be used when
result files are written (\code{toFile=TRUE}), but the file extension can be
set to something else using this function argument.}

\item{outputDirectory}{directory in which output files are stored. Defaults
to NULL which means that the result file will be stored in the same
directory as the input file.}

\item{knownLossless}{a list of file extensions associated with known
lossless file encodings.}

\item{logToFile}{whether to log commands to a separate logfile in the
\code{outputDirectory}. Logging will otherwise be in the \code{acfana} logging
namespace of \link{logger} and will be put wherever this namespace is defined to place its output.
See \link[logger:log_appender]{logger::log_appender} for details.}

\item{verbose}{display verbose information about processing steps taken, as
well as progress bars.}
}
\description{
The RMS amplitude is computed for each window of \code{windowSize}
length in the input signals files liste in \code{listOfFiles}. Per default, the
RMS values are expressed in decibel (dB) so that they correspond to the
short-term power of the signal. Input signals not in the native "wav" file
format will be converted before the function is applied. The conversion
process will display warnings about input files that are not in known
losslessly encoded formats.

The results will be will be written to an SSFF formated file with the base
name of the input file and extension \emph{.rms} in a track \emph{rms}.
}
\details{
The function is a re-write of the \link[wrassp:rmsana]{wrassp::rmsana} function, but
with media pre-conversion, better checking of preconditions such as the
input file existence, structured logging, and the use of a more modern
framework for user feedback.

The native file type of this function is "wav" files (in "pcm_s16le"
format), SUNs "au", NIST, or CSL formats (kay or NSP extension). Input
signal conversion, when needed, is done by
\href{https://ffmpeg.org/libavcodec.html}{libavcodec} and the excellent \link{av}
wrapper package.
}
\examples{
# get path to audio file
path2wav <- list.files(system.file("samples","sustained", package = "superassp"), pattern = glob2rx("a.wav"), full.names = TRUE)

# calculate short-term autocorrelation
res <- rmsana(path2wav, toFile=FALSE)


# plot rms values
plot(seq(0,numRecs.AsspDataObj(res) - 1) / rate.AsspDataObj(res) +
      attr(res, 'startTime'),
    res$rms,
    type='l',
    xlab='time (s)',
    ylab='RMS energy (dB)')

}
\seealso{
\link[wrassp:rmsana]{wrassp::rmsana}

\link{AsspWindowTypes}

\link[av:encoding]{av::av_audio_convert}
}
